import logging
from time import time
from multiprocessing import Pool, cpu_count
from colors import *

logging.basicConfig(level=logging.DEBUG, format="%(message)s" ) 


def factorize(*number):
    """функції factorize, яка приймає список чисел та повертає список чисел, на які числа з вхідного списку поділяються без залишку.
    тобто знаходить всі цілі додатні дільки які є у вказаного числа/чисел"""
    result_div = list()
    for num in number:
        number_list = list()
        for i in range(1, num + 1):
            if num % i == 0:
                number_list.append(i)
        result_div.append(number_list)
    return result_div


if __name__ == '__main__':
    start_time = time() # Визначаємо поточний час (вцьому випадку це початок запуску роботи функції *factorize(*number) )

    a, b, c, d  = factorize(128, 255, 99999, 10651060) # Запуск нашої функції .Зміним *(a, b, c, d) буде присвоєно відповідний список всіх дільників відповідного числа.
                                                       # Тобто *а-присвоються споск дільників числа 128, *b-присвоються споск дільників числа 255 і так дальше за порядком.

    assert a == [1, 2, 4, 8, 16, 32, 64, 128 ] # Оператор *assert - дозволяє порівняти фактични результати з тими що ми очікуєм. 
                                              # В нашому випадку зміна *а отримає з функції *factorize дільники числа 128. 
                                              # Вони відповідають тим результатам що ми очікуємо тому помилок повертатись небуде .
                                              # Примітка : assert *фактични_результат == *очікуваний_результат (якщо вони неспівпадають поверне помилку *AssertionError)
    assert b == [1, 3, 5, 15, 17, 51, 85, 255]
    assert c == [1, 3, 9, 41, 123, 271, 369, 813, 2439, 11111, 33333, 99999]
    assert d == [1, 2, 4, 5, 7, 10, 14, 20, 28, 35, 70, 140, 76079, 152158, 304316, \
                 380395, 532553, 760790, 1065106, 1521580, 2130212, 2662765, 5325530, 10651060]
    
    end_time = time() # Визначаємо поточний час (вцьому випадку це кінець роботи функції *factorize(*number) )
    logging.info(f'{GREEN}Time: {RED}{end_time - start_time:.5f} {GREEN}by-sec') # від часу початку віднімаємо час кінця і принтимо його . 
                                                                                 # Це і буде час виконання обрахунків нашою функцією. 
                                                                                 # Примітка : *:.5f- це запис який означає відображати 5 знаків після коми.

    proc_cores = cpu_count() # Функція повертає кількість фактичний ядер в процесорі.
    with Pool(proc_cores) as thr: # За допомогою менеджера контексту запускаємо пул процесів (в нашому випадку їх буде 4 оскільки процесор 4-ядерний)
        start_time = time() # Визначаємо поточний час (вцьому випадку це початок запуску роботи функції *factorize(*number) )
        results = thr.map(factorize, (128, 255, 99999, 10651060))
        end_time = time()# Визначаємо поточний час (вцьому випадку це кінець роботи функції *factorize(*number) )
        logging.info(f'{GREEN}Time for {proc_cores} core(s): {RED}{end_time - start_time:.5f} {GREEN}by-sec{DEFALUT}')# від часу початку віднімаємо час кінця і принтимо його . 
                                                                                 # Це і буде час виконання обрахунків нашою функцією. 
                                                                                 # Примітка : *:.5f- це запис який означає відображати 5 знаків після коми.

        