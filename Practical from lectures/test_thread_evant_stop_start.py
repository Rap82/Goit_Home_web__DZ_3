# ======================  Реалізація багатопоточності класу EVANT(Зупинка виконаня залежного процесу і подальший його повторний запуск).=========================================
# Evant - клас для управління потоками . Можна визначати який потік є основний а які залежні.

from threading import Thread, Event

import logging
from time import sleep



def worker(event:Event, event_for_exist : Event): # функція яка приймає два  аргумент екзепляр  класу *Event, функція в якій реалізовано наш додатковий потік,
                         # який буде запускатися з дозволу основного потоку функції *master(event:Event) через методом *event.set()
                         # виконує свої дії тільки після дозволу мастера.
    while True :
        
        if event_for_exist.is_set(): # Умова зупинки виконання *worker(event:Event) як тільки основний потік мастер дасть команду, виконання воркера завершиться 
                           # В нашому випадку це 5 сек . 
            break
        
        if event.is_set():
            sleep(1)
            logging.info(f"Очікування подальшого виконання потоку")
            continue
        else:
            sleep(1) # встановлюємо паузу в 1 сек .
            logging.info(f"DDos server")# Вивід повіомлення про викоання додаткового потоку .
    


if __name__ == "__main__":

    logging.basicConfig(level=logging.DEBUG, format="%(threadName)s %(message)s") # вбудована функція для логування  потоків за їх іменем *%(threadName)s 
    
    event = Event() # Створення *пустого екзепляру класу *Event Примітка : пустий означає 
    event_exist = Event() # Створення *пустого екзепляру класу *Event Примітка : пустий означає 

    
    work1 = Thread(target=worker, args=(event, event_exist))# Реалізація залежного потоку екзепляру класу *Thread який запуститься в потоці функціію *worker(event, event_for_exist) після того як основний потік дасть команду на виконання.
                                                                # з двома аргументами *event і event_for_exist - *пустими екзеплярами класу *Event()
    
    work1.start() # Стартуємо перший залежний потік
    logging.info("Start program")
    sleep(2)    # встановлюємо паузу в 2 сек

    event.set() # дозвіл на запуск додаткових потоків в нашому випадку буде зупиняти додатковий потік.
    logging.info("Stop thread")
    sleep(2)
    event.clear() # метод *екзкпляр_event.clear() очищає поточний стан виконання *event.set()
    logging.info("Start thread")
    sleep(2)
    event_exist.set() # завершуємо роботу  залежного потоку .(даємо повторну команду залежному потоку на виконання , після виконання він завершиться)
    logging.info("End program")

# ++++++++++++++++++++++++++++++++++ Результат роботи коду ++++++++++++++++++++++++++++++++++++++++++++++

# MainThread Start program # Зпускається потік
# Thread-1 (worker) DDos server # Виконання завдання потоку 
# Thread-1 (worker) DDos server # Виконання завдання потоку 
# MainThread Stop thread  # Призупинямов відразу виконання 
# Thread-1 (worker) Очікування подальшого виконання потоку  # Очікуємо команди на повтрний старт завдання 
# Thread-1 (worker) Очікування подальшого виконання потоку  # Очікуємо команди на повтрний старт завдання 
# MainThread Start thread  # Зпускається потік повторно
# Thread-1 (worker) DDos server # Виконання завдання потоку
# MainThread End program        # Вивід завершення роботи програми 
# Thread-1 (worker) DDos server # Виконання останього завдання потоку

# Примітка : кількість подій який виконуються залежить від інтервалу встановленому в функції *sleep(*час)



